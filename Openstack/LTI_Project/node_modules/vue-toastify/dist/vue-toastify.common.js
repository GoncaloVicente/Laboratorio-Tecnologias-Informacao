module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "24fb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "35b0":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("3bfe");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__("499e").default
var update = add("b388fa44", content, true, {"sourceMap":false,"shadowMode":false});

/***/ }),

/***/ "3bfe":
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__("24fb");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".vt-notification-container{pointer-events:none;-webkit-box-sizing:border-box;box-sizing:border-box;position:fixed;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin:10px;width:auto;height:auto;z-index:9999}.vt-backdrop-hidden{-webkit-transition:all .15s ease-out;transition:all .15s ease-out;opacity:0;visibility:hidden;z-index:50;top:0;left:0;right:0;bottom:0;position:fixed}.vt-backdrop-visible{opacity:1;visibility:visible}.vt-top{top:0}.vt-centerY{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.vt-bottom{bottom:0}.vt-left{left:0}.vt-centerX{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.vt-right{right:0}.vt-center-center{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vt-success{border-color:#199919}.vt-success>.vt-icon>svg{fill:#199919}.vt-info{border-color:#003bc8}.vt-info>.vt-icon>svg{fill:#003bc8}.vt-warning{border-color:#ffb300}.vt-warning>.vt-icon>svg{fill:#ffb300}.vt-error{border-color:#b11414}.vt-error>.vt-icon>svg{fill:#b11414}.vt-notification{-webkit-transition:-webkit-transform .1s ease;transition:-webkit-transform .1s ease;transition:transform .1s ease;transition:transform .1s ease,-webkit-transform .1s ease;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:auto;-webkit-box-shadow:0 0 10px .5px rgba(0,0,0,.35);box-shadow:0 0 10px .5px rgba(0,0,0,.35);padding:10px 20px;min-height:100px;min-width:250px;border-radius:5px;margin-bottom:10px;margin-left:auto;margin-right:auto;z-index:9999;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:wrap row;flex-flow:row wrap;-ms-flex-line-pack:center;align-content:center}.vt-notification>.vt-progress-bar{height:3px;width:100%;margin-bottom:5px}.vt-notification>.vt-progress-bar>.vt-progress{max-width:100%;height:3px;overflow:hidden;-webkit-transition:max-width 1ms ease-in-out;transition:max-width 1ms ease-in-out}.vt-notification>.vt-content{width:auto;height:100%;max-width:250px;word-break:break-word}.vt-notification>.vt-content>.vt-title{font-size:1.4rem;margin:0}.vt-notification>.vt-content>.vt-paragraph{font-size:1rem;margin:.5rem 0}.vt-notification>.vt-circle{border-style:solid;border-width:2px;width:65px;height:65px;border-radius:50%;margin:5px!important}.vt-notification>.vt-icon-container{margin:0 20px;position:relative}.vt-notification>.vt-icon-container>.vt-icon{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vt-notification>.vt-buttons{-ms-flex-preferred-size:100%;flex-basis:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-line-pack:center;align-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:space-evenly;-ms-flex-pack:space-evenly;justify-content:space-evenly;margin:5px -23px 0}.vt-notification>.vt-buttons>button{-ms-flex-preferred-size:48%;flex-basis:48%;width:auto;margin-bottom:4px;border-radius:4px}@media (max-width:268px){.vt-notification{min-height:auto;min-width:100%;border-radius:0}.vt-notification>.vt-content{text-align:center}.vt-notification-container{width:100%;margin:0}}.vt-will-change{will-change:transform,opacity}.vt-move{-webkit-transition-timing-function:ease-in-out;transition-timing-function:ease-in-out;-webkit-transition-property:all;transition-property:all;-webkit-transition-duration:.2s;transition-duration:.2s}.vt-move[data-delayed=true]{-webkit-transition-delay:.2s!important;transition-delay:.2s!important}.vt-spinner{width:60px;height:60px;border-radius:50%;background-color:transparent;-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite}.vt-cursor-wait{cursor:wait}.vt-cursor-pointer{cursor:pointer}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.vt-theme-dark{background-color:#1d1d1d}.vt-theme-dark>.vt-progress-bar{background-color:#373737}.vt-theme-dark>.vt-progress-bar>.vt-progress{background-color:#6a6a6a}.vt-theme-dark>.vt-content>.vt-title{color:#dcdcdc}.vt-theme-dark>.vt-content>.vt-paragraph{color:#dcdcdc}.vt-theme-dark>.vt-buttons>button{border:1px solid #373737;background-color:#373737;color:#dcdcdc;-webkit-transition:all .2s ease-out;transition:all .2s ease-out}.vt-theme-dark>.vt-buttons>button:hover{background-color:#c3c3c3;color:#2a2a2a;-webkit-transition:all .2s ease-out;transition:all .2s ease-out}.vt-theme-dark>.vt-prompt{border-color:#d0d0d0}.vt-theme-dark>.vt-prompt>.vt-icon>svg{fill:#d0d0d0}.vt-theme-dark>.vt-icon-container>.vt-spinner{border:2px solid #6a6a6a;border-top:2px solid #fff}.vt-theme-light{background-color:#f0f0f0}.vt-theme-light>.vt-progress-bar{background-color:#d7d7d7}.vt-theme-light>.vt-progress-bar>.vt-progress{background-color:#a4a4a4}.vt-theme-light>.vt-content>.vt-title{color:#313131}.vt-theme-light>.vt-content>.vt-paragraph{color:#313131}.vt-theme-light>.vt-buttons>button{border:1px solid #d7d7d7;background-color:#d7d7d7;color:#313131;-webkit-transition:all .2s ease-out;transition:all .2s ease-out}.vt-theme-light>.vt-buttons>button:hover{background-color:#4a4a4a;color:#e3e3e3;-webkit-transition:all .2s ease-out;transition:all .2s ease-out}.vt-theme-light>.vt-prompt{border-color:#3e3e3e}.vt-theme-light>.vt-prompt>.vt-icon>svg{fill:#3e3e3e}.vt-theme-light>.vt-icon-container>.vt-spinner{border:2px solid #a4a4a4;border-top:2px solid #0b0b0b}.vt-bottom-enter-active,.vt-center-enter-active,.vt-left-enter-active,.vt-right-enter-active,.vt-top-enter-active{-webkit-transition:all .2s ease-out;transition:all .2s ease-out}.vt-bottom-leave-active,.vt-center-leave-active,.vt-left-leave-active,.vt-right-leave-active,.vt-top-leave-active{-webkit-transition:all .2s ease-in;transition:all .2s ease-in}.vt-right-enter,.vt-right-leave-to{-webkit-transform:translateX(50px);transform:translateX(50px);opacity:0}.vt-left-enter,.vt-left-leave-to{-webkit-transform:translateX(-50px);transform:translateX(-50px);opacity:0}.vt-bottom-enter,.vt-bottom-leave-to{-webkit-transform:translateY(50px);transform:translateY(50px);opacity:0}.vt-top-enter,.vt-top-leave-to{-webkit-transform:translateY(-50px);transform:translateY(-50px);opacity:0}.vt-center-enter,.vt-center-leave-to{opacity:0}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "499e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ addStylesClient; });

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    if (document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "a27d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_3_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VueToastify_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("35b0");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_3_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VueToastify_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_3_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VueToastify_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_3_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_4_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VueToastify_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3dd62c10-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/VueToastify.vue?vue&type=template&id=2e6e3e23&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"vt-backdrop-hidden",class:{
            'vt-backdrop-visible':
                _vm.toasts.length > 0 && _vm.settings.withBackdrop
        },style:({
            backgroundColor: _vm.settings.backdrop
        })}),_c('vt-transition',{staticClass:"vt-notification-container",class:_vm.positionClasses,style:(_vm.flexDirection),attrs:{"transition":_vm.getTransition,"position":_vm.settings.position}},_vm._l((_vm.toasts),function(status){return _c('Toast',{key:status.id,attrs:{"status":status,"base-icon-class":_vm.settings.baseIconClass}})}),1)],1)}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/VueToastify.vue?vue&type=template&id=2e6e3e23&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3dd62c10-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Toast.vue?vue&type=template&id=d7bb276a&
var Toastvue_type_template_id_d7bb276a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.tag,_vm._b({tag:"component",staticClass:"vt-notification",class:_vm.notificationClass,style:(_vm.draggableStyles),attrs:{"draggable":"false"},on:{"mouseenter":function($event){_vm.isHovered = true},"mouseleave":function($event){_vm.isHovered = false},"touchstart":function($event){_vm.isHovered = true},"touchend":function($event){_vm.isHovered = false}}},'component',_vm.urlTarget,false),[(_vm.isNotification && _vm.status.canTimeout)?_c('ProgressBar',{ref:'progress-' + _vm.status.id,attrs:{"can-pause":_vm.status.canPause,"duration":_vm.status.duration,"is-hovered":_vm.isHovered,"hide-progressbar":_vm.status.hideProgressbar,"id":_vm.status.id},on:{"vtFinished":_vm.closeNotification}}):_vm._e(),_c('div',{staticClass:"vt-content"},[(_vm.status.title)?_c('h2',{staticClass:"vt-title",domProps:{"textContent":_vm._s(_vm.status.title)}}):_vm._e(),_c('p',{staticClass:"vt-paragraph",domProps:{"innerHTML":_vm._s(_vm.status.body)}})]),(_vm.status.iconEnabled)?_c('Icon',{attrs:{"mode":_vm.status.mode,"type":_vm.status.type,"icon":_vm.status.icon,"base-icon-class":_vm.baseIconClass}}):_vm._e(),(_vm.status.mode === 'prompt')?_c('div',{staticClass:"vt-buttons"},_vm._l((_vm.status.answers),function(value,answerProperty,index){return _c('button',{key:index,domProps:{"textContent":_vm._s(answerProperty)},on:{"click":function($event){return _vm.respond(value)}}})}),0):_vm._e()],1)}
var Toastvue_type_template_id_d7bb276a_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/Toast.vue?vue&type=template&id=d7bb276a&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3dd62c10-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ProgressBar.vue?vue&type=template&id=263d3e6d&
var ProgressBarvue_type_template_id_263d3e6d_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.hideProgressbar),expression:"!hideProgressbar"}],staticClass:"vt-progress-bar"},[_c('div',{staticClass:"vt-progress",style:({ width: this.progress + '%' })})])}
var ProgressBarvue_type_template_id_263d3e6d_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/ProgressBar.vue?vue&type=template&id=263d3e6d&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ProgressBar.vue?vue&type=script&lang=js&
//
//
//
//
//
//
var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
/* harmony default export */ var ProgressBarvue_type_script_lang_js_ = ({
  name: "ProgressBar",
  props: {
    canPause: {
      type: Boolean
    },
    canTimeout: {
      type: Boolean
    },
    isHovered: {
      type: Boolean
    },
    hideProgressbar: {
      type: Boolean
    },
    duration: {
      type: Number
    },
    id: {
      type: String
    }
  },
  beforeMount: function beforeMount() {
    this.timerFinishesAt = new Date(this.duration + Date.now());
  },
  mounted: function mounted() {
    var _this = this;

    this.$root.$emit("vtStarted", {
      id: this.id
    }); // start of the timer (a constant)

    this.timerStartedAt = new Date(); // initial time to calculate with on the first start

    this.timerPausedAt = new Date();

    if (!this.canPause) {
      // set new timeout
      this.timerId = window.setTimeout(function () {
        return _this.$emit("vtFinished");
      }, this.timerFinishesAt.getTime() - Date.now()); // animation start

      this.progressId = requestAnimationFrame(this.progressBar);
    }

    this.timerStart();
  },
  data: function data() {
    return {
      progress: 0,
      progressId: null,
      timerId: null,
      timerStartedAt: null,
      timerPausedAt: null,
      timerFinishesAt: null
    };
  },
  methods: {
    timerStart: function timerStart() {
      var _this2 = this;

      if (this.canPause) {
        this.timerStartedAt = new Date(this.timerStartedAt.getTime() + (Date.now() - this.timerPausedAt.getTime())); // new future date = future date + elapsed time since pausing

        this.timerFinishesAt = new Date(this.timerFinishesAt.getTime() + (Date.now() - this.timerPausedAt.getTime()));

        if (!this.timerId && this.progress > 0) {
          this.$root.$emit("vtResumed", {
            id: this.id
          });
        } // set new timeout


        this.timerId = window.setTimeout(function () {
          return _this2.$emit("vtFinished");
        }, this.timerFinishesAt.getTime() - Date.now()); // animation start

        this.progressId = requestAnimationFrame(this.progressBar);
      }
    },
    timerPause: function timerPause() {
      if (this.canPause) {
        // stop notification from closing
        window.clearTimeout(this.timerId); // set to null so animation won't stay in a loop

        this.timerId = null; // stop loader animation from progressing

        cancelAnimationFrame(this.progressId);
        this.progressId = null;
        this.$root.$emit("vtPaused", {
          id: this.id
        });
        this.timerPausedAt = new Date();
      }
    },
    progressBar: function progressBar() {
      if (this.progress < 100) {
        var wholeTime = this.timerFinishesAt.getTime() - this.timerStartedAt.getTime();
        var elapsed = Date.now() - this.timerStartedAt.getTime();
        this.progress = elapsed / wholeTime * 100; // if timer is running

        if (this.timerId) {
          this.progressId = requestAnimationFrame(this.progressBar);
        }
      } else {
        this.progressId = cancelAnimationFrame(this.progressId);
      }
    }
  },
  watch: {
    isHovered: function isHovered(boolean) {
      if (boolean) {
        this.timerPause();
      } else {
        this.timerStart();
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.progress = 0;
    window.clearTimeout(this.timerId);

    if (this.progressId) {
      cancelAnimationFrame(this.progressId);
      this.progressId = null;
    }
  }
});
// CONCATENATED MODULE: ./src/components/ProgressBar.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ProgressBarvue_type_script_lang_js_ = (ProgressBarvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/components/ProgressBar.vue





/* normalize component */

var component = normalizeComponent(
  components_ProgressBarvue_type_script_lang_js_,
  ProgressBarvue_type_template_id_263d3e6d_render,
  ProgressBarvue_type_template_id_263d3e6d_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProgressBar = (component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3dd62c10-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Icon.vue?vue&type=template&id=18151dfb&
var Iconvue_type_template_id_18151dfb_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"vt-icon-container",class:_vm.containerClasses},[(_vm.userIcon)?_c(_vm.userIcon.tag,{tag:"component",staticClass:"vt-icon",class:_vm.userIcon.class,domProps:{"innerHTML":_vm._s(_vm.userIcon.ligature)}}):(_vm.mode === 'loader')?_c('div',{staticClass:"vt-spinner"}):(_vm.mode === 'prompt')?_c('div',{staticClass:"vt-icon"},[_c('svg',{staticStyle:{"width":"24px","height":"24px"},attrs:{"viewBox":"0 0 24 24"}},[_c('path',{attrs:{"d":"M10,19H13V22H10V19M12,2C17.35,2.22 19.68,7.62 16.5,11.67C15.67,12.67 14.33,13.33 13.67,14.17C13,15 13,16 13,17H10C10,15.33 10,13.92 10.67,12.92C11.33,11.92 12.67,11.33 13.5,10.67C15.92,8.43 15.32,5.26 12,5A3,3 0 0,0 9,8H6A6,6 0 0,1 12,2Z"}})])]):(_vm.containerClasses['vt-success'])?_c('div',{staticClass:"vt-icon"},[_c('svg',{attrs:{"xmlns":"http://www.w3.org/2000/svg","width":"36","height":"36","viewBox":"0 0 24 24"}},[_c('path',{attrs:{"d":"M9 16.2l-3.5-3.5c-.39-.39-1.01-.39-1.4 0-.39.39-.39 1.01 0 1.4l4.19 4.19c.39.39 1.02.39 1.41 0L20.3 7.7c.39-.39.39-1.01 0-1.4-.39-.39-1.01-.39-1.4 0L9 16.2z"}})])]):(_vm.containerClasses['vt-error'])?_c('div',{staticClass:"vt-icon"},[_c('svg',{attrs:{"xmlns":"http://www.w3.org/2000/svg","width":"36","height":"36","viewBox":"0 0 24 24"}},[_c('path',{attrs:{"d":"M18.3 5.71c-.39-.39-1.02-.39-1.41 0L12 10.59 7.11 5.7c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L10.59 12 5.7 16.89c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L12 13.41l4.89 4.89c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L13.41 12l4.89-4.89c.38-.38.38-1.02 0-1.4z"}})])]):(_vm.containerClasses['vt-warning'])?_c('div',{staticClass:"vt-icon"},[_c('svg',{attrs:{"xmlns":"http://www.w3.org/2000/svg","width":"36","height":"36","viewBox":"0 0 24 24"}},[_c('circle',{attrs:{"cx":"12","cy":"19","r":"2"}}),_c('path',{attrs:{"d":"M12 3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2s2-.9 2-2V5c0-1.1-.9-2-2-2z"}})])]):(_vm.containerClasses['vt-info'])?_c('div',{staticClass:"vt-icon"},[_c('svg',{staticStyle:{"transform":"rotate(180deg)"},attrs:{"xmlns":"http://www.w3.org/2000/svg","width":"36","height":"36","viewBox":"0 0 24 24"}},[_c('path',{attrs:{"d":"M12 3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2s2-.9 2-2V5c0-1.1-.9-2-2-2z"}}),_c('circle',{attrs:{"cx":"12","cy":"19","r":"2"}})])]):_vm._e()],1)}
var Iconvue_type_template_id_18151dfb_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/Icon.vue?vue&type=template&id=18151dfb&

// CONCATENATED MODULE: ./src/js/utils.js
var isBoolean = function isBoolean(value) {
  return typeof value === "boolean";
};
var isString = function isString(value) {
  return typeof value === "string";
};
var isObject = function isObject(value) {
  return value === Object(value);
};
var isBetween = function isBetween(value, min, max) {
  return value > min && value <= max;
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Icon.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var Iconvue_type_script_lang_js_ = ({
  name: "Icon",
  props: {
    mode: {
      type: String
    },
    type: {
      type: String
    },
    icon: {
      type: [Object, String]
    },
    baseIconClass: {
      type: String,
      default: ""
    }
  },
  computed: {
    userIcon: function userIcon() {
      if (!this.icon) {
        return false;
      }

      var icon = {
        tag: "i",
        ligature: "",
        class: this.baseIconClass
      };

      if (isString(this.icon)) {
        if (this.icon.toLowerCase().includes("<svg")) {
          icon.tag = "div";
          icon.ligature = this.icon;
        } else {
          icon.class = icon.class + " " + this.icon;
        }
      }

      if (isObject(this.icon)) {
        icon = Object.assign(icon, this.icon);
      }

      return icon;
    },
    containerClasses: function containerClasses() {
      var obj = {};

      if (this.mode !== "loader") {
        obj["vt-circle"] = !this.icon;
      }

      obj["vt-prompt"] = this.mode === "prompt";

      if (this.mode === undefined || this.mode.length === 0) {
        obj["vt-" + (this.type ? this.type : "info")] = true;
      }

      return obj;
    }
  }
});
// CONCATENATED MODULE: ./src/components/Icon.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Iconvue_type_script_lang_js_ = (Iconvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/Icon.vue





/* normalize component */

var Icon_component = normalizeComponent(
  components_Iconvue_type_script_lang_js_,
  Iconvue_type_template_id_18151dfb_render,
  Iconvue_type_template_id_18151dfb_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Icon = (Icon_component.exports);
// CONCATENATED MODULE: ./src/components/draggable.js
/* harmony default export */ var draggable = ({
  data: function data() {
    return {
      dragStartPos: {},
      dragPos: {},
      isDragged: false,
      boundingClientRect: {}
    };
  },
  mounted: function mounted() {
    if (this.status.draggable) {
      this.$el.addEventListener("touchstart", this.dragStarted);
      this.$el.addEventListener("mousedown", this.dragStarted);
      addEventListener("touchmove", this.beingDragged);
      addEventListener("mousemove", this.beingDragged);
      addEventListener("touchend", this.dragFinished);
      addEventListener("mouseup", this.dragFinished);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.status.draggable) {
      this.$el.removeEventListener("touchstart", this.dragStarted);
      this.$el.removeEventListener("mousedown", this.dragStarted);
      removeEventListener("touchmove", this.beingDragged);
      removeEventListener("mousemove", this.beingDragged);
      removeEventListener("touchend", this.dragFinished);
      removeEventListener("mouseup", this.dragFinished);
    }
  },
  computed: {
    hasMoved: function hasMoved() {
      return this.dragPos.x !== undefined && this.dragStartPos.x !== this.dragPos.x;
    },
    dragXDistance: function dragXDistance() {
      return this.isDragged ? this.dragPos.x - this.dragStartPos.x : 0;
    },
    removalDistance: function removalDistance() {
      return this.boundingClientRect.width * this.status.dragThreshold;
    },
    draggableStyles: function draggableStyles() {
      if (this.dragStartPos.x === this.dragPos.x || !this.hasMoved) {
        return {};
      }

      var opacity = 1 - Math.abs(this.dragXDistance / this.removalDistance);
      opacity = isNaN(opacity) ? 1 : opacity;
      return {
        transform: "translateX(" + this.dragXDistance + "px)",
        opacity: opacity,
        "user-select": "none"
      };
    }
  },
  methods: {
    dragStarted: function dragStarted(event) {
      this.$el.classList.toggle("vt-will-change");
      this.isDragged = true;
      this.dragStartPos = {
        x: this.xPos(event),
        y: this.yPos(event)
      };
      this.boundingClientRect = this.$el.getBoundingClientRect();
    },
    beingDragged: function beingDragged(event) {
      // prevent page scroll
      event.preventDefault();

      if (this.isDragged) {
        this.dragPos = {
          x: this.xPos(event),
          y: this.yPos(event)
        };

        if (!this.hasMoved) {
          this.$root.$emit("vtDragStarted", {
            id: this.status.id,
            position: this.dragStartPos
          });
        } else {
          this.$root.$emit("vtBeingDragged", {
            id: this.status.id,
            position: this.dragPos
          });
        }
      }
    },
    dragFinished: function dragFinished() {
      var _this = this;

      if (this.hasMoved) {
        this.$root.$emit("vtDragFinished", {
          id: this.status.id,
          position: this.dragPos
        }); // todo if at least 75% of the notification is out of the window (in case of mobile)
        // eslint-disable-next-line no-unused-vars

        var isAlmostOffRight = this.$el.getBoundingClientRect().right > window.innerWidth && this.$el.getBoundingClientRect().right - window.innerWidth > this.boundingClientRect.width * 0.75; // eslint-disable-next-line no-unused-vars

        var isAlmostOffLeft = this.$el.getBoundingClientRect().right < this.boundingClientRect.width * 0.25;

        if (Math.abs(this.boundingClientRect.left - this.$el.getBoundingClientRect().left) > this.removalDistance) {
          this.closeNotification();
        }

        this.isDragged = false; // execute after the next event cycle

        setTimeout(function () {
          _this.dragPos = {};
          _this.dragStartPos = {};

          _this.$el.classList.toggle("vt-will-change");
        });
      }
    },
    xPos: function xPos(event) {
      return event.targetTouches && event.targetTouches.length > 0 ? event.targetTouches[0].clientX : event.clientX;
    },
    yPos: function yPos(event) {
      return event.targetTouches && event.targetTouches.length > 0 ? event.targetTouches[0].clientY : event.clientY;
    }
  }
});
// CONCATENATED MODULE: ./src/components/linkable.js

/* harmony default export */ var linkable = ({
  computed: {
    tag: function tag() {
      if (!this.hasUrl) {
        return "div";
      }

      return "a";
    },
    hasUrl: function hasUrl() {
      return isString(this.status.url) && this.status.url.length > 0 || isObject(this.status.url) && (this.routerRouteExits || !!this.status.url.href);
    },
    urlTarget: function urlTarget() {
      if (this.status.url) {
        if (isString(this.status.url)) {
          if (!this.routerRouteExits) {
            return {
              href: this.status.url
            };
          }

          return {
            href: this.$vtRouter.resolve(this.status.url).href
          };
        }

        if (isObject(this.status.url)) {
          if (!this.isRouterLinkObject && this.status.url.href) {
            return this.status.url;
          }

          if (this.routerRouteExits) {
            return {
              href: this.$vtRouter.resolve(this.status.url).href
            };
          }

          return {};
        }
      }

      return {};
    },
    isRouterLinkObject: function isRouterLinkObject() {
      return !!this.status.url.path || !!this.status.url.name;
    },
    routerRouteExits: function routerRouteExits() {
      var _this = this;

      if (this.$vtRouter) {
        return !!this.$vtRouter.options.routes.find(function (route) {
          return route.path === "/" + _this.status.url.path || route.path === _this.status.url.path || route.name === _this.status.url.name;
        });
      }

      return false;
    }
  },
  methods: {
    handleRedirect: function handleRedirect(event) {
      if (this.hasUrl) {
        // if it's a browser level link
        if (isObject(this.status.url) && this.status.url.href || isString(this.status.url) && !this.routerRouteExits) {
          return;
        }

        event.preventDefault();

        if (this.$vtRouter) {
          this.$vtRouter.push(this.status.url);
        }
      }
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Toast.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var Toastvue_type_script_lang_js_ = ({
  name: "Toast",
  components: {
    ProgressBar: ProgressBar,
    Icon: Icon
  },
  props: {
    status: {
      type: Object
    },
    baseIconClass: {
      type: String,
      default: ""
    }
  },
  mixins: [draggable, linkable],
  data: function data() {
    return {
      isHovered: false
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$el.addEventListener("click", this.dismiss);

    if (this.status.mode === "loader") {
      this.$root.$once("vtLoadStop", function (payload) {
        //if all loaders should stop or only this
        if (payload.id) {
          if (payload.id === _this.status.id) {
            _this.closeNotification();
          }
        } else {
          _this.closeNotification();
        }
      });
    }
  },
  computed: {
    notificationClass: function notificationClass() {
      var obj = {};

      if (this.hasUrl) {
        obj["vt-cursor-pointer"] = true;
      } else if (this.status.mode === "loader") {
        obj["vt-cursor-wait"] = true;
      }

      obj["vt-theme-" + this.status.theme] = true;
      return obj;
    },
    isNotification: function isNotification() {
      return ["prompt", "loader"].indexOf(this.status.mode) === -1;
    }
  },
  methods: {
    closeNotification: function closeNotification() {
      var progress = Math.ceil(this.$refs["progress-" + this.status.id] ? this.$refs["progress-" + this.status.id].progress : undefined); // if notification manually dismissed before the the timeout or in case if it cannot timeout AND isn't prompt or loader

      if ((isNaN(progress) || progress < 100) && this.isNotification) {
        this.$root.$emit("vtDismissed", {
          id: this.status.id
        });
        this.status.callback ? this.status.callback() : null;
      } // if the notification has finished displaying


      if (progress >= 100 && this.isNotification) {
        this.$root.$emit("vtFinished", {
          id: this.status.id
        });
        this.status.callback ? this.status.callback() : null;
      }
    },
    dismiss: function dismiss(event) {
      if (this.isNotification && !this.hasMoved) {
        this.closeNotification();
      }

      this.handleRedirect(event);
    },
    respond: function respond(response) {
      this.closeNotification();
      this.$root.$emit("vtPromptResponse", {
        id: this.status.id,
        response: response
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.$el.removeEventListener("click", this.dismiss);
  }
});
// CONCATENATED MODULE: ./src/components/Toast.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Toastvue_type_script_lang_js_ = (Toastvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/Toast.vue





/* normalize component */

var Toast_component = normalizeComponent(
  components_Toastvue_type_script_lang_js_,
  Toastvue_type_template_id_d7bb276a_render,
  Toastvue_type_template_id_d7bb276a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Toast = (Toast_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3dd62c10-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Transition.vue?vue&type=template&id=2e9c255d&
var Transitionvue_type_template_id_2e9c255d_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition-group',{attrs:{"name":_vm.transition.name ? _vm.transition.name : _vm.transition,"css":true,"tag":"div","move-class":_vm.transition.moveClass ? _vm.transition.moveClass : 'vt-move'},on:{"leave":_vm.leave,"before-enter":_vm.beforeEnter,"after-enter":_vm.afterEnter,"before-leave":_vm.beforeLeave}},[_vm._t("default")],2)}
var Transitionvue_type_template_id_2e9c255d_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/Transition.vue?vue&type=template&id=2e9c255d&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Transition.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var Transitionvue_type_script_lang_js_ = ({
  name: "Transition",
  props: {
    transition: {
      type: [String, Object],
      required: true
    },
    position: {
      type: String,
      required: true
    }
  },
  methods: {
    // todo - consider will-change
    leave: function leave(el) {
      if (this.$parent.singular || this.$parent.oneType && this.$parent.$el.childNodes.length === 1) {
        return;
      }

      var position = this.position.split("-"); // https://forum.vuejs.org/t/transition-group-move-class-not-occuring-in-the-array/6381/5
      // these rules ensure the toast stays where it is

      var _window$getComputedSt = window.getComputedStyle(el),
          height = _window$getComputedSt.height,
          width = _window$getComputedSt.width,
          marginBottom = _window$getComputedSt.marginBottom; // when the last toast removed the container collapses hence the need for the width subtraction


      el.style.left = el.offsetLeft - (el.parentNode.childNodes.length === 1 ? parseInt(width) : 0) + "px";
      el.style.top = el.offsetTop + "px";

      if (position[0] === "center") {
        el.style.top = parseInt(el.style.top) - parseInt(height) / 2 - parseInt(marginBottom) / 2 + "px";
      }

      if (position[0] === "bottom") {
        el.style.top = parseInt(el.style.top) - parseInt(height) - parseInt(marginBottom) + "px";
      } // absolute position may mess with the width so lets set to initial


      el.style.width = width;
      el.style.position = "absolute";
    },
    beforeEnter: function beforeEnter(el) {
      // no delay on making space for notification
      this.$el.childNodes.forEach(function (node) {
        return delete node.dataset.delayed;
      });

      if (el.__vue__.status.delayed) {
        el.dataset.delayed = true;
        el.classList.add("vt-move");
        delete el.__vue__.status.delayed;
      }
    },
    afterEnter: function afterEnter(el) {
      el.removeAttribute("data-delayed");
    },
    beforeLeave: function beforeLeave(el) {
      // this ensures that notifications won't move until the other has been removed
      for (var i = 0; i < el.parentNode.childNodes.length; i++) {
        if (el.parentNode.childNodes[i].isSameNode(el)) {
          continue;
        }

        el.parentNode.childNodes[i].dataset.delayed = true;
      }

      el.classList.remove("vt-default-position");
    }
  }
});
// CONCATENATED MODULE: ./src/components/Transition.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Transitionvue_type_script_lang_js_ = (Transitionvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/Transition.vue





/* normalize component */

var Transition_component = normalizeComponent(
  components_Transitionvue_type_script_lang_js_,
  Transitionvue_type_template_id_2e9c255d_render,
  Transitionvue_type_template_id_2e9c255d_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Transition = (Transition_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/VueToastify.vue?vue&type=script&lang=js&
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// todo backdrop to transition with dragging if that's the only one left in the toasts and next isn't queued?
// todo: create 3 containers and create a manager that manages the queue to push to the correct container (each container having 3 positions) ( position will be held on the status ) this will allow for separated transitions



var temp = {};
/* harmony default export */ var VueToastifyvue_type_script_lang_js_ = ({
  name: "VueToastify",
  components: {
    Toast: Toast,
    "vt-transition": Transition
  },
  props: {
    singular: {
      type: Boolean,
      default: false
    },
    withBackdrop: {
      type: Boolean,
      default: false
    },
    backdrop: {
      type: String,
      default: "rgba(0, 0, 0, 0.2)"
    },
    position: {
      validator: function validator(value) {
        // The value must match one of these strings
        return ["top-left", "top-center", "top-right", "center-left", "center-center", "center-right", "bottom-left", "bottom-center", "bottom-right"].indexOf(value) !== -1;
      },
      default: "bottom-right"
    },
    defaultTitle: {
      type: Boolean,
      default: true
    },
    canPause: {
      type: Boolean,
      default: true
    },
    canTimeout: {
      type: Boolean,
      default: true
    },
    iconEnabled: {
      type: Boolean,
      default: true
    },
    draggable: {
      type: Boolean,
      default: true
    },
    dragThreshold: {
      type: Number,
      default: 0.75,
      validator: function validator(value) {
        return isBetween(value, 0, 5);
      }
    },
    hideProgressbar: {
      type: Boolean,
      default: false
    },
    errorDuration: {
      type: Number,
      default: 8000
    },
    successDuration: {
      type: Number,
      default: 4000
    },
    warningInfoDuration: {
      type: Number,
      default: 6000
    },
    theme: {
      type: String,
      default: "dark"
    },
    baseIconClass: {
      type: String,
      default: ""
    },
    orderLatest: {
      type: Boolean,
      default: true
    },
    transition: {
      type: [String, Object],
      default: function _default() {}
    },
    oneType: {
      type: Boolean,
      default: false
    },
    maxToasts: {
      type: Number,
      default: 6
    }
  },
  data: function data() {
    return {
      toasts: [],
      queue: [],
      settings: {
        singular: false,
        withBackdrop: false,
        backdrop: "rgba(0, 0, 0, 0.2)",
        position: "bottom-right",
        defaultTitle: true,
        canTimeout: true,
        canPause: false,
        iconEnabled: true,
        draggable: true,
        dragThreshold: 0.75,
        hideProgressbar: false,
        errorDuration: 8000,
        successDuration: 4000,
        warningInfoDuration: 6000,
        theme: "dark",
        baseIconClass: "",
        orderLatest: true,
        transition: null,
        oneType: false,
        maxToasts: 6
      }
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.setSettings(); // listen for notification events

    this.$root.$on(["vtFinished", "vtDismissed", "vtPromptResponse", "vtLoadStop"], function (payload) {
      if (typeof payload.id === "string") {
        _this.remove(payload.id);
      }
    }); // if there is a notification assigned to the window

    if (window.notification && window.notification.type && window.notification.body) {
      var delay = window.notification.delay ? window.notification.delay : 0;
      setTimeout(function () {
        _this.add(window.notification);
      }, delay);
    }
  },
  methods: {
    //---Internal methods---//

    /**
     * Find the toast with the given id in the toasts
     * and return its index from the array
     *
     * @return {Number}
     */
    findToast: function findToast(id) {
      return this.toasts.findIndex(function (toast) {
        return toast.id === id;
      });
    },

    /**
     * Find the toast with the given id in the queue
     * and return its index from the array
     *
     * @return {Number}
     */
    findQueuedToast: function findQueuedToast(id) {
      return this.queue.findIndex(function (toast) {
        return toast.id === id;
      });
    },

    /**
     * Returns a UUID.
     *
     * @returns {String}
     */
    uuidv4: function uuidv4() {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (c) {
        return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
      });
    },

    /**
     * Figure out the title from the status object.
     *
     * @param {Object} status
     *
     * @return {String}
     */
    getTitle: function getTitle(status) {
      if (status.title) {
        return status.title;
      }

      if (isBoolean(status.defaultTitle)) {
        if (status.defaultTitle) {
          if (status.mode === "prompt" || status.mode === "loader") {
            return "";
          }

          if (status.type) {
            return status.type.charAt(0).toUpperCase() + status.type.slice(1);
          }
        } else {
          return "";
        }
      }

      if (this.settings.defaultTitle) {
        if (status.mode === "prompt" || status.mode === "loader") {
          return "";
        }

        if (status.type) {
          return status.type.charAt(0).toUpperCase() + status.type.slice(1);
        }
      }

      return "Info";
    },

    /**
     * Check if the toast already is being displayed.
     *
     * @param {Object} status
     *
     * @return {Boolean}
     */
    arrayHasType: function arrayHasType(status) {
      return !!this.toasts.find(function (toast) {
        return toast.mode && toast.mode === status.mode || toast.type && toast.type === status.type;
      });
    },
    //---API methods---//

    /**
     * Merges the passed in settings where the key exists
     * in the original. If no argument merge refresh
     * from the original settings.
     *
     * @param {Object} settings
     *
     * @return {Object<*>}
     */
    setSettings: function setSettings() {
      var _this2 = this;

      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (settings) {
        Object.keys(this.settings).forEach(function (key) {
          if (settings[key] !== undefined) {
            _this2.$set(_this2.settings, key, settings[key]);
          }
        });
      } else {
        this.settings = Object.assign({}, this._props);
      }

      return this.settings;
    },

    /**
     * If argument set return the given setting,
     * else return the settings object.
     *
     * @param {String} setting
     *
     * @return {Object|*}
     */
    getSettings: function getSettings() {
      var setting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return this.settings[setting] ? this.settings[setting] : this.settings;
    },

    /**
     * Dismiss the loader for the given ids
     * or all of the loaders. Return
     * the count of the dismissed
     * loaders.
     *
     * @param {String|String[]} id
     *
     * @return {Number}
     */
    stopLoader: function stopLoader() {
      var _this3 = this;

      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var ids = id;

      if (typeof id === "string") {
        ids = [id];
      } else if (Array.isArray(id)) {
        ids = id;
      } else {
        //get all loaders
        ids = this.toasts.map(function (toast) {
          if (toast.mode === "loader") {
            return toast.id;
          }
        });
      }

      ids.forEach(function (id) {
        _this3.$root.$emit("vtLoadStop", {
          id: id
        });
      });
      return ids.length;
    },

    /**
     * Add a new toast object to the toasts
     * or queue respectively with all
     * the parameters assigned.
     * Return the uuid.
     *
     * @param {Object} status
     *
     * @return {String}
     */
    add: function add(status) {
      // copy object
      var toast = Object.assign({}, status); //todo update to deep copy
      // if object doesn't have default values, set them

      toast.duration = this.settings.warningInfoDuration;

      if (Number(status.duration) > 0) {
        toast.duration = Number(status.duration);
      } else if (status.type) {
        toast.duration = status.type === "error" ? this.settings.errorDuration : status.type === "success" ? this.settings.successDuration : this.settings.warningInfoDuration;
      }

      toast.answers = status.answers && Object.keys(status.answers).length > 0 ? status.answers : {
        Yes: true,
        No: false
      };
      toast.canPause = isBoolean(status.canPause) ? status.canPause : this.settings.canPause;
      toast.hideProgressbar = isBoolean(status.hideProgressbar) ? status.hideProgressbar : this.settings.hideProgressbar;
      toast.id = this.uuidv4();
      toast.title = this.getTitle(status);
      toast.canTimeout = isBoolean(status.canTimeout) ? status.canTimeout : this.settings.canTimeout;
      toast.iconEnabled = isBoolean(status.iconEnabled) ? status.iconEnabled : this.settings.iconEnabled;

      if (["prompt", "loader"].indexOf(status.mode) === -1) {
        toast.draggable = isBoolean(status.draggable) ? status.draggable : this.settings.draggable;
      } else {
        toast.draggable = false;
      }

      toast.dragThreshold = isBetween(status.dragThreshold, 0, 5) ? status.dragThreshold : this.settings.dragThreshold;

      if (status.mode === "prompt" || status.mode === "loader") {
        toast.canTimeout = false;
      }

      toast.theme = status.theme ? status.theme : this.settings.theme;

      if ( // if singular and there's 1 already showing
      this.settings.singular && this.toasts.length > 0 || // if oneType turned on and that type already showing
      this.settings.oneType && this.arrayHasType(toast) || // if it would exceed the max number of displayed toasts
      this.toasts.length >= this.settings.maxToasts) {
        this.$set(this.queue, this.queue.length, toast);
        return toast.id;
      }

      this.$set(this.toasts, this.toasts.length, toast);
      return toast.id;
    },

    /**
     * Find the toast from the toast
     * or the queue, if not found
     * return false, otherwise
     * return all.
     *
     * @param {String} id
     *
     * @return {Boolean|Object|Object[]}
     */
    get: function get() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (id) {
        var toast = this.toasts.find(function (toast) {
          return toast.id === id;
        });

        if (!toast) {
          toast = this.queue.find(function (toast) {
            return toast.id === id;
          });
        }

        if (!toast) {
          return false;
        }

        return toast;
      }

      return this.toasts.concat(this.queue);
    },

    /**
     * Update a toast by merging the
     * argument and the existing status.
     * Returns whether the update was
     * successful or not.
     *
     * @param {String} id
     * @param {Object} status
     *
     * @return {Boolean}
     */
    set: function set(id, status) {
      var toast = this.get(id);

      if (!toast || toast instanceof Array) {
        return false;
      }

      if (this.findToast(id) !== -1) {
        this.$set(this.toasts, this.findToast(id), Object.assign(toast, status));
        return true;
      }

      this.$set(this.toasts, this.findQueuedToast(id), Object.assign(toast, status));
      return true;
    },

    /**
     * If id giver, removes the corresponding
     * toast else remove all. If id not
     * found returns false, otherwise
     * an array of ids currently
     * visible to the user.
     *
     * @param {String} id
     * @return {Boolean|Array}
     */
    remove: function remove() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (id) {
        var index = this.findQueuedToast(id);

        if (this.settings.singular && index !== -1) {
          this.$delete(this.queue, index);
          return this.currentlyShowing;
        }

        index = this.findToast(id);

        if (index !== -1) {
          this.$delete(this.toasts, index);
          return this.currentlyShowing;
        }

        return false;
      }

      this.toasts = [];
      return this.currentlyShowing;
    }
  },
  computed: {
    /**
     * Return the appropriate transition
     * based on the position.
     *
     * @return {String}
     */
    getTransition: function getTransition() {
      if (this.settings.transition) {
        return this.settings.transition;
      }

      var position = this.settings.position.split("-");

      if (position[1] === "left") {
        return "vt-left";
      }

      if (position[1] === "center") {
        return "vt-" + position[0];
      }

      return "vt-right";
    },

    /**
     * Return a style object for determining
     * the toasts order.
     *
     * @return {Object}
     */
    flexDirection: function flexDirection() {
      return {
        "flex-direction": this.settings.orderLatest && this.settings.position.split("-")[0] === "bottom" ? "column" : "column-reverse"
      };
    },

    /**
     * Return the appropriate classes
     * based on the position.
     *
     * @return {Object}
     */
    positionClasses: function positionClasses() {
      var position = this.settings.position.split("-");
      var classes = {};

      if (position[0] === position[1]) {
        classes["vt-center-center"] = true;
        return classes;
      }

      classes[position[0] === "center" ? "vt-centerY" : "vt-" + position[0]] = true;
      classes[position[1] === "center" ? "vt-centerX" : "vt-" + position[1]] = true;
      return classes;
    },

    /**
     * Returns the ids of all the toasts
     * currently visible to the user.
     * @return {String[]}
     */
    currentlyShowing: function currentlyShowing() {
      return this.toasts.map(function (toast) {
        return toast.id;
      });
    }
  },
  watch: {
    settings: {
      handler: function handler(newSettings, oldSettings) {
        if (isBoolean(newSettings.singular)) {
          // if singular turned off release all queued toasts
          if (!newSettings.singular) {
            for (var i = 0; i < this.settings.maxToasts - 1; i++) {
              if (!this.queue[i]) {
                continue;
              }

              if (!this.arrayHasType(this.queue[i])) {
                this.$set(this.toasts, this.toasts.length, this.queue.splice(i, 1)[0]);
              }
            }

            if (isBoolean(temp.orderLatest)) {
              newSettings.orderLatest = temp.orderLatest;
              delete temp.orderLatest;
            }

            return;
          }

          temp.orderLatest = oldSettings.orderLatest;
          newSettings.orderLatest = false;
        }
      },
      deep: true
    },
    toasts: {
      handler: function handler(newValue) {
        var _this4 = this;

        // if there's anything at all in the queue
        if (this.queue.length !== 0) {
          this.$nextTick(function () {
            // if singular than oneType and maxToasts isn't a concern
            if (_this4.settings.singular) {
              if (newValue.length === 0) {
                _this4.$set(_this4.toasts, _this4.toasts.length, _objectSpread({}, _this4.queue.shift(), {
                  delayed: true
                }));
              }

              return;
            }

            if (_this4.settings.oneType) {
              return _this4.queue.forEach(function (status, index) {
                if (!_this4.arrayHasType(status) && _this4.toasts.length < _this4.settings.maxToasts) {
                  _this4.$set(_this4.toasts, _this4.toasts.length, _objectSpread({}, _this4.queue.splice(index, 1)[0], {
                    delayed: true
                  }));
                }
              });
            }

            if (_this4.toasts.length < _this4.settings.maxToasts) {
              _this4.$set(_this4.toasts, _this4.toasts.length, _objectSpread({}, _this4.queue.shift(), {
                delayed: true
              }));
            }
          });
        }
      },
      deep: true
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.$root.$off(["vtFinished", "vtDismissed", "vtPromptResponse", "vtLoadStop"]);
  }
});
// CONCATENATED MODULE: ./src/components/VueToastify.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_VueToastifyvue_type_script_lang_js_ = (VueToastifyvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/VueToastify.vue?vue&type=style&index=0&lang=scss&
var VueToastifyvue_type_style_index_0_lang_scss_ = __webpack_require__("a27d");

// CONCATENATED MODULE: ./src/components/VueToastify.vue






/* normalize component */

var VueToastify_component = normalizeComponent(
  components_VueToastifyvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var VueToastify = (VueToastify_component.exports);
// CONCATENATED MODULE: ./src/VueToastify.js
function VueToastify_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function VueToastify_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { VueToastify_ownKeys(Object(source), true).forEach(function (key) { VueToastify_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { VueToastify_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function VueToastify_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var VueToastify_VueToastify = {
  install: function install(Vue) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var router = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var Constructor = Vue.extend(VueToastify);
    var ToastContainer = new Constructor();

    if (router) {
      Vue.prototype.$vtRouter = router;
    }

    ToastContainer._props = Object.assign(ToastContainer._props, settings);
    var vm = ToastContainer.$mount();
    document.querySelector("body").appendChild(vm.$el);

    if (typeof window !== "undefined" && window.Vue) {
      window.Vue.use(ToastContainer);
    }

    var vtNotify = function vtNotify(status) {
      var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (typeof status === "string") {
        status = {
          body: status
        };
      }

      if (title) {
        status.title = title;
      }

      if (!status.type) {
        status.type = "success";
      }

      return ToastContainer.add(status);
    };

    var toastify = {
      success: function success(status) {
        var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        return vtNotify(status, title);
      },
      info: function info(status) {
        var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (typeof status === "string") {
          status = {
            body: status
          };
        }

        if (title) {
          status.title = title;
        }

        status.type = "info";
        return vtNotify(status);
      },
      warning: function warning(status) {
        var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (typeof status === "string") {
          status = {
            body: status
          };
        }

        if (title) {
          status.title = title;
        }

        status.type = "warning";
        return vtNotify(status);
      },
      error: function error(status) {
        var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (typeof status === "string") {
          status = {
            body: status
          };
        }

        if (status.status && status.statusText) {
          status = {
            title: status.status.toString(),
            body: status.statusText
          };
        }

        if (title) {
          status.title = title;
        }

        status.type = "error";
        return vtNotify(status);
      },
      loader: function loader(status) {
        var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (typeof status === "string") {
          status = {
            body: status
          };
        }

        if (title) {
          status.title = title;
        }

        status.mode = "loader";
        return vtNotify(status);
      },
      prompt: function prompt(status) {
        var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (typeof status === "string") {
          status = {
            body: status
          };
        }

        if (title) {
          status.title = title;
        }

        status.mode = "prompt";
        var id = ToastContainer.add(status);
        return new Promise(function (resolve) {
          ToastContainer.$root.$once("vtPromptResponse", function (payload) {
            if (payload.id === id) {
              resolve(payload.response);
            }
          });
        });
      },
      stopLoader: function stopLoader() {
        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        ToastContainer.stopLoader(id);
      },
      getToast: function getToast() {
        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return ToastContainer.get(id);
      },
      changeToast: function changeToast(id, status) {
        return ToastContainer.set(id, status);
      },
      removeToast: function removeToast() {
        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return ToastContainer.remove(id);
      },
      setSettings: function setSettings(settings) {
        return ToastContainer.setSettings(settings);
      },
      getSettings: function getSettings() {
        var setting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return ToastContainer.getSettings(setting);
      },
      listen: function listen(event, callback) {
        return ToastContainer.$on(event, function (payload) {
          return callback(payload);
        });
      },
      listenOnce: function listenOnce(event, callback) {
        return ToastContainer.$once(event, function (payload) {
          return callback(payload);
        });
      }
    };

    if (settings.customNotifications && Object.entries(settings.customNotifications).length > 0) {
      Object.entries(settings.customNotifications).forEach(function (keyValArr) {
        Object.defineProperty(toastify, keyValArr[0], {
          get: function get() {
            return function (status) {
              var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var toast = {};
              toast = Object.assign(toast, keyValArr[1]);

              if (typeof status === "string") {
                toast.body = status;
              } else {
                toast = VueToastify_objectSpread({}, keyValArr[1], {}, status);
              }

              if (title) {
                toast.title = title;
              }

              return vtNotify(toast);
            };
          }
        });
      });
    }

    Vue.prototype.$vtNotify = vtNotify;
    Vue.$vtNotify = vtNotify;
    Vue.prototype.$vToastify = toastify;
    Vue.$vToastify = toastify;
  }
};
/* harmony default export */ var src_VueToastify = (VueToastify_VueToastify);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (src_VueToastify);



/***/ })

/******/ });